## Exercise 3.47

### Part A - Define a semaphore in terms of mutexes

I needed some help with this solution. I thought a semaphore of size $n$ would require $n$ concurrent mutexes. This is not true, rather, instead of storing the state in a boolean `cell` like with the mutex, we need to store how many of up to $n$ operation have acquired the semaphore.

I found a solution online and tested the solution in `resources/3-46.scm`. I've added comments to understand how this solution works.

``` Scheme
(define (make-semaphore n)
  (let ((count n) ;how many more operations can acquire the semaphore
        (the-mutex (make-mutex)))
    (define (the-semaphore m)
      (cond ((eq? m 'acquire)
             ;mutex ensures count can't be decremented concurrently
             (the-mutex 'acquire)
             ;if no more operations can acquire the semaphore
             (if (zero? count)
                 ;then keep trying until there is capacity
                 (begin
                   (the-mutex 'release)
                   (the-semaphore 'acquire))
                 ;else decrement capacity
                 (begin
                   (set! count (- count 1))
                   (the-mutex 'release))))
            ((eq? m 'release)
             ;mutex ensures count can't be incremented concurrently
             (the-mutex 'acquire)
             ;if semaphore is already fully free
             (if (= count n)
                 ;then just do nothing and release the mutex
                 (the-mutex 'release)
                 ;else increment the count to free capacity
                 (begin
                   (set! count (+ count 1))
                   (the-mutex 'release))))))
    the-semaphore))
```

### Part B

Instead of using the mutex definition, we can use the internal implementation of the mutex directly, which is implemented using `cell` and `test-and-set!`.

There was the bug in the online solution I found by [Barry Allison](https://wizardbook.wordpress.com/2010/12/19/exercise-3-47/). If we call `acquire` and there is zero capacity, we need to keep retrying, same as in the first example. 

``` Scheme
(define (make-semaphore n)
  (let ((count n)
        (cell (list false)))
    (define (the-semaphore m)
      (cond ((eq? m 'acquire)
             ;if mutex is acquired
             (if (test-and-set! cell)
                 ;then retry
                 (the-semaphore 'acquire)
                 ;else if no more operations can acquire the semaphore
                 (if (zero? count)
                     ;then keep trying until there is capacity
                     (begin
                       (clear! cell)
                       (the-semaphore 'acquire))
                     ;else decrement capacity
                     (begin
                       (set! count (- count 1))
                       (clear! cell)))))
            ((eq? m 'release)
             ;if mutex is acquired
             (if (test-and-set! cell)
                 ;then retry
                 (the-semaphore 'release)
                 ;else if semaphore is fully free
                 (if (= count n)
                     ;then do nothing and release the mutex
                     (clear! cell)
                     ;else increment capacity
                     (begin
                       (set! count (+ count 1))
                       (clear! cell)))))))
    the-semaphore))
```