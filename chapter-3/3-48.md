## Exercise 3.48

### Explanation

The deadlock-avoidance method as described in the textbook works because if we can guarantee that the lowest-numbered account is always locked _first_, then as each thread attempts to lock the same account, we can guarantee they will wait for each other sequentially.

Because all threads are acquiring the same mutex, they will all each in turn wait for the mutex to be released.

If two threads locked account A and account B respectively, and both tried to complete the exchange by acquiring the lock on the other account, they would enter a deadlock.

### Solution

Firstly we assign an account number to each account. We ignore the issue of being able to assign duplicate account numbers for the time being, and assume each account will be assigned a unique account number.

``` Scheme
(define (make-account balance account-number)
  (define (withdraw amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount))
               balance)
        "Insufficient funds"))
  (define (deposit amount)
    (set! balance (+ balance amount))
    balance)
  (let ((balance-serializer (make-serializer)))
    (define (dispatch m)
      (cond ((eq? m 'withdraw) withdraw)
            ((eq? m 'deposit) deposit)
            ((eq? m 'balance) balance)
            ((eq? m 'serializer) balance-serializer)
            ((eq? m 'account-number) account-number)
            (else (error "Unknown request -- MAKE-ACCOUNT"
                         m))))
    dispatch))
```

Then if the account number of `account1` is less than `account2`, we always enter that account's serializer first, else we enter `account2`'s serializer first. That way we always enter the lowest numbered account first.


``` Scheme
(define (serialized-exchange account1 account2)
  (let ((serializer1 (account1 'serializer))
        (serializer2 (account2 'serializer))
        (account-number1 (account1 'account-number))
        (account-number2 (account2 'account-number)))
    (if (< account-number1 account-number2)
        ((serializer1 (serializer2 exchange))
         account1
         account2)
        ((serializer2 (serializer1 exchange))
         account1
         account2))
    ))
```

In order to test this in `mit-scheme`, I added some delay after entering the first serializer, so that when you start two threads on a fast modern computer, you will have a much better chance of entering two exchanges concurrently.

``` Scheme
; procedure with deadlocking bug
(define (serialized-exchange account1 account2)
  (let ((serializer1 (account1 'serializer))
        (serializer2 (account2 'serializer)))
    ((serializer1 
      (lambda ()
        ;; After getting first lock, sleep to give other thread a chance
        (sleep-current-thread 100)  ; 100ms delay
        ((serializer2 exchange)
         account1
         account2))))))

; fixed procedure
(define (serialized-exchange account1 account2)
  (let ((serializer1 (account1 'serializer))
        (serializer2 (account2 'serializer))
        (account-number1 (account1 'account-number))
        (account-number2 (account2 'account-number)))
    (if (< account-number1 account-number2)
        ((serializer1 
          (lambda ()
            ;; After getting first lock, sleep to give other thread a chance
            (sleep-current-thread 100)  ; 100ms delay
            ((serializer2 exchange)
            account1
            account2))))
        ((serializer2 
          (lambda ()
            ;; After getting first lock, sleep to give other thread a chance
            (sleep-current-thread 100)  ; 100ms delay
            ((serializer1 exchange)
            account1
            account2)))))
    ))
```

My full test script is in `resources/3-48.scm`