# Exercise 5.5

## Hand-simulating the factorial machine

Controller instruction sequence of the factorial machine:

```
(controller
   (assign continue (label fact-done))     ; set up final return address
 fact-loop
   (test (op =) (reg n) (const 1))
   (branch (label base-case))
   ;; Set up for the recursive call by saving n and continue.
   ;; Set up continue so that the computation will continue
   ;; at after-fact when the subroutine returns.
   (save continue)
   (save n)
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-fact))
   (goto (label fact-loop))
 after-fact
   (restore n)
   (restore continue)
   (assign val (op *) (reg n) (reg val))   ; val now contains n(n-1)!
   (goto (reg continue))                   ; return to caller
 base-case
   (assign val (const 1))                  ; base case: 1!=1
   (goto (reg continue))                   ; return to caller
 fact-done)
```

Simulating for $3!$,

1. Register n is 3
1. Assign `continue` to be `fact-done`
1. Is n equal to 1? No, n is 3
1. Save `continue` and `n` to the stack:
    ```
    stack
    -----
    fact-done
    3
    ```
1. Assign `n = n-1 = 2`, `continue` to be `after-fact`
1. Goto `fact-loop`
1. Is n equal to 1? No, n is 2
1. Save `continue` and `n` to the stack:
    ```
    stack
    -----
    fact-done
    3
    after-fact
    2
    ```
1. Assign `n = n-1 = 1`, `continue` to be `after-fact`
1. Goto `fact-loop`
1. Is n equal to 1? Yes, branch to `base-case`
1. Assign `val = 1`
1. Goto value of `continue` which is `after-fact`
1. Restore `n = 2` and `continue = after-fact`:
    ```
    stack
    -----
    fact-done
    3
    ```
1. Assign `val = n*val = 2*1 = 2`
1. Goto value of `continue` which is `after-fact`
1. Restore `n = 3` and `continue = fact-done`:
    ```
    stack
    -----
    (empty)
    ```
1. Assign `val = n*val = 3*2 = 6`
1. Goto value of `continue` which is `fact-done`

Machine halts, `val = 6`

## Hand-simulating the Fibonacci machine

Controller instruction sequence of the Fibonacci machine:

```
(controller
   (assign continue (label fib-done))
 fib-loop
   (test (op <) (reg n) (const 2))
   (branch (label immediate-answer))
   ;; set up to compute Fib(n-1)
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)                           ; save old value of n
   (assign n (op -) (reg n) (const 1)); clobber n to n-1
   (goto (label fib-loop))            ; perform recursive call
 afterfib-n-1                         ; upon return, val contains Fib(n-1)
   (restore n)
   (restore continue)
   ;; set up to compute Fib(n-2)
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)                         ; save Fib(n-1)
   (goto (label fib-loop))
 afterfib-n-2                         ; upon return, val contains Fib(n-2)
   (assign n (reg val))               ; n now contains Fib(n-2)
   (restore val)                      ; val now contains Fib(n-1)
   (restore continue)
   (assign val                        ; Fib(n-1)+Fib(n-2)
           (op +) (reg val) (reg n)) 
   (goto (reg continue))              ; return to caller, answer is in val
 immediate-answer
   (assign val (reg n))               ; base case: Fib(n)=n
   (goto (reg continue))
 fib-done)
```

Simulating for n = 3,

1. Register n is 3
1. Assign `continue` to be `fib-done`
1. Is n < 2? No, n is 3
1. Save `continue` to the stack:
    ```
    stack
    -----
    fib-done
    ```
1. Assign `continue` to be `afterfib-n-1`
1. Save n to the stack:
    ```
    stack
    -----
    fib-done
    3
    ```
1. Assign n = n-1 = 2
1. Goto `fib-loop`
1. Is n < 2? No, n is 2
1. Save `continue` to the stack:
    ```
    stack
    -----
    fib-done
    3
    afterfib-n-1
    ```
1. Assign `continue` to be `afterfib-n-1`
1. Save n to the stack:
    ```
    stack
    -----
    fib-done
    3
    afterfib-n-1
    2
    ```
1. Assign n = n-1 = 1
1. Goto `fib-loop`
1. Is n < 2? Yes, n is 1
1. Branch to `immediate-answer`
1. Assign `val = n = 1`
1. Goto value of `continue` which is `afterfib-n-1`
1. Restore `n = 2` and `continue = afterfib-n-1`:
    ```
    stack
    -----
    fib-done
    3
    ```
1. Assign `n = n-2 = 0`
1. Save `continue` to the stack:
    ```
    stack
    -----
    fib-done
    3
    afterfib-n-1
    ```
1. Assign `continue = afterfib-n-2`
1. Save `val` to the stack:
    ```
    stack
    -----
    fib-done
    3
    afterfib-n-1
    1
    ```
1. Goto `fib-loop`
1. Is n < 2? Yes, n is 0
1. Branch to `immediate-answer`
1. Assign `val = n = 0`
1. Goto `continue = afterfib-n-2`
1. Assign `n = val = 0`
1. Restore `val = 1` and `continue = afterfib-n-1`:
    ```
    stack
    -----
    fib-done
    3
    ```
1. Assign `val = val+n = 1+0 = 1`
1. Goto `continue = afterfib-n-1`
1. Restore `n = 3, continue = fib-done`
    ```
    stack
    -----
    (empty)
    ```
1. Assign `n = n-2 = 1`
1. Save `continue = fib-done`
    ```
    stack
    -----
    fib-done
    ```
1. Assign `continue = afterfib-n-2`
1. Save `val = 1`
    ```
    stack
    -----
    fib-done
    1
    ```
1. Goto `fib-loop`
1. Is n < 2? Yes, n is 1
1. Branch to `immediate-answer`
1. Assign `val = n = 1`
1. Goto `continue = afterfib-n-2`
1. Assign `n = val = 1`
1. Restore `val = 1, continue = fib-done`
    ```
    stack
    -----
    (empty)
    ```
1. Assign `val = val+n = 1+1 = 2`
1. Goto `continue = fib-done`

Machine halts, `val = 2`