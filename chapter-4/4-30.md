# Exercise 4.30

## Part A

The procedure `for-each` relies on the special form `begin`, which is evaluated using `eval-sequence`. The first argument to `begin`, `(proc (car items))` gets fully evaluated immediately, because the operator `proc` is forced, and the operand `(car items)` has `car` as a primitive procedure which is also evaluated immediately.

So Ben is right in this particular case that the sequence of procedures are evaluated in order, but not in general.

``` Scheme
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
```

## Part B

Values of `(p1 1)` and `(p2 1)` with the original `eval-sequence`:

``` Scheme
;;; L-Eval input:
(p1 1)
;;; L-Eval value:
(1 2)

;;; L-Eval input:
(p2 1)
;;; L-Eval value:
1
```

With Cy's proposed change to `eval-sequence`:

``` Scheme
;;; L-Eval input:
(p1 1)
;;; L-Eval value:
(1 2)

;;; L-Eval input:
(p2 1)
;;; L-Eval value:
(1 2)
```

## Part C

In Part A, I explained that for this particular case, each element in the sequence is forced immediately in the standard lazy evaluator implementation, because `(proc (car items))` consists of an operator and a primitive procedure. But this is not true in general. 

Cy's version of `eval-sequence` will always ensure each element in a sequence to be forced immediately, in general as well as in this particular case where it is being forced anyway. So that's why they get the same result.

## Part D

Cy's example in Part B relies on strange properties of side effects, which in general are to be avoided if possible, as the book explains.

Cy's approach does seem to be more predictable and prevents subtle bugs. It works accurately with side effects for more general cases.

However, Cy's approach is fundamentally less lazy - it forces `eval-sequence` to fully evaluate sooner. Therefore Cy's approach is trading laziness for greater clarity and predictability when it comes to side effects.