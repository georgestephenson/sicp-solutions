# Exercise 4.27

``` Scheme
(define count 0)

(define (id x)
  (set! count (+ count 1))
  x)

(define w (id (id 10)))

;;; L-Eval input:
count
;;; L-Eval value:
1
```

Explanation: `count` gets set to 1 when `w` is defined. When evaluating `(define w (id (id 10)))`, the evaluation of `(id (id 10))` is forced as normal. The lazy evaluator didn't change the implementation of `eval-definition`, which calls `eval` on this expression. However, because the inner expression `(id 10)` is an argument to a compound procedure (the outer `id`), the evaluation of this procedure gets delayed.

In other words, when `(define w (id (id 10)))` is called, the outer call to `id` is evaluated eagerly, which increments `count` once. The inner call to `id` is delayed.

``` Scheme
;;; L-Eval input:
w
;;; L-Eval value:
10
```

In this case, the `driver-loop` is forcing the `actual-value` of `w` to be evaluated. The procedure `id` always returns its input, so the nested calls to `id` both return `10`.

``` Scheme
;;; L-Eval input:
count
;;; L-Eval value:
2
```

In the above explanation we noted that the inner call to `id` was delayed because it is an argument to a compound procedure. After the `driver-loop` forced the evaluation of `w`, that call to `id` is now forced to evaluate, which will set `count` to 2.