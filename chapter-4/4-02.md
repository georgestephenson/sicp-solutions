# Exercise 4.2

## Part A

The condition for procedure applications called `application?` only checks the expression is a pair using `pair?`. This is a looser condition than the other cases with reserved words, as it's designed to be the last case. Because it's looser, assignments will be evaluated by the case, and never reach the case with condition `assignment?`.

For example, `(define x 3)` will be evaluated as a standard procedure: the first step will be to evaluate the operator:

``` Scheme
(eval (operator exp) env)
```

The reserved word `define` will be treated as an operator, and when `eval` is called with `define` as an argument, the procedure will attempt to find `define` as a variable (`variable?`) and fail.

## Part B

In order to make it so that procedure applications start with `call`, for example users must write `(call + 1 2)` instead of `(+ 1 2)`:

``` Scheme
; Louis's change to eval
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        (else
         (error "Unknown expression type -- EVAL" exp))))

; required fix to evaluation of procedure applications
; so that procedure applications start with "call"
(define (application? exp) (tagged-list? exp 'call))
(define (operator exp) (cadr exp))
(define (operands exp) (cddr exp))
```