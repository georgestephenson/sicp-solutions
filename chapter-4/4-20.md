# Exercise 4.20

## Part A

We add this condition to `eval`

``` Scheme
((letrec? exp) (eval (letrec->letset! exp) env))
```

The key idea is to transform `letrec` into a combination of `let` and `set!` operations:

``` Scheme
(define (binding->set! binding)
  (let ((v (car binding))
        (e (cadr binding)))
    (list 'set! v e)))

(define (letrec->letset! exp)
  (let* ((bindings (cadr exp))
         (vars (let-vars bindings))
         (body (cddr exp)))
    (cons 'let
          (cons (map (lambda (v) (list v ''*unassigned*)) vars)
                (append (map binding->set! bindings)
                        body)))))
```

Full code example in `resources/4-20.scm`.

## Part B

Recursive definitions in the `let` can't reference to each other with the same frame of the environment, but they can in `letrec`.

![Environment diagram for `letrec`](img/4-20A.png)

*Environment diagram for `letrec`*

![Environment diagram for `let`](img/4-20B.png)

*Environment diagram for `let`*