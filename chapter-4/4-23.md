# Exercise 4.23

## Work done by `analyze-sequence` for one expression

Alyssa's version of `analyze-sequence`:

``` Scheme
(define (analyze-sequence exps)
  (define (execute-sequence procs env)
    (cond ((null? (cdr procs)) ((car procs) env))
          (else ((car procs) env)
                (execute-sequence (cdr procs) env))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence -- ANALYZE"))
    (lambda (env) (execute-sequence procs env))))
```

Alyssa's version of `analyze-sequence`, in the case where there is only one expression in the sequence, then `execute-sequence` is equivalent to:

``` Scheme
(define (execute-sequence procs env)
    ((car procs) env))
```

The error case will not be hit for a sequence of one element, so we can ignore that, which makes `analyze-sequence` equivalent to:

``` Scheme
(define (analyze-sequence exps)
  (define (execute-sequence procs env)
    ((car procs) env))
  (let ((procs (map analyze exps)))
    (lambda (env) (execute-sequence procs env))))
```

The original version of `analyze-sequence`:

``` Scheme
(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
        first-proc
        (loop (sequentially first-proc (car rest-procs))
              (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
        (error "Empty sequence -- ANALYZE"))
    (loop (car procs) (cdr procs))))
```

If there's only one expression in the sequence, loop is equivalent to:

``` Scheme
(define (loop first-proc rest-procs)
    first-proc)
```

So `loop` could be substituted with the argument to `first-proc`, and since `sequentially` is unused, and the error case is not valid, we can exclude those to get an equivalent procedure:

``` Scheme
(define (analyze-sequence exps)
  (let ((procs (map analyze exps)))
    (car procs)))
```

Next to simplified form of Alyssa's version for one expression:

``` Scheme
(define (analyze-sequence exps)
  (define (execute-sequence procs env)
    ((car procs) env))
  (let ((procs (map analyze exps)))
    (lambda (env) (execute-sequence procs env))))
```

Alyssa's version will defer calling `execute-sequence` until the sequence is executed, and will need to call this every time it is executed, rather than doing it once at analysis time.

## Work done by `analyze-sequence` for two expressions

If the sequence has two expressions, then in the original version, using substitution we arrive at:

``` Scheme
(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (let ((procs (map analyze exps)))
    (sequentially (car procs) (cadr procs))))
```

Substituting further:

``` Scheme
(define (analyze-sequence exps)
  (let ((procs (map analyze exps)))
    (lambda (env) ((car procs) env) ((cadr procs) env))))
```

Next to Alyssa's version with the error case excluded:

``` Scheme
(define (analyze-sequence exps)
  (define (execute-sequence procs env)
    (cond ((null? (cdr procs)) ((car procs) env))
          (else ((car procs) env)
                (execute-sequence (cdr procs) env))))
  (let ((procs (map analyze exps)))
    (lambda (env) (execute-sequence procs env))))
```

The original version clearly does the work of analysing the full sequence of the two expressions to be executed by building a lambda that with this structure. The sequence is looped through at analysis time, and a lambda is built. However, in Alyssa's version, the first `execute-sequence` will not be executed until runtime and so the sequence must be looped through every time (not just once at analysis time).