# Exercise 4.26

Ben is right that `unless` can be implemented in applicative order as a special form. It is almost the same as the `if` special form, which allows "lazy evaluation" in applicative form, but with the consequence and the alternative in swapped order.

However, "lazy evaluation" is not quite accurate, as in the case of `if`, either the consequent or the alternative are evaluated lazily - never both. One of the expressions will not be evaluated at all, which is why it is a special form.

That said, `unless` can be implemented in the original metacircular evaluator example easily:

``` Scheme
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((unless? exp) (eval-unless exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))

(define (unless? exp) (tagged-list? exp 'unless))

(define (unless-condition exp) (cadr exp))

(define (unless-usual-value exp) (caddr exp))

(define (unless-exceptional-value exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (eval-unless exp env)
  (if (true? (eval (unless-condition exp) env))
      (eval (unless-exceptional-value exp) env)
      (eval (unless-usual-value exp) env)))
```

Alyssa's point is that using `unless` as a special form, or derived expression, means that it can't be used as a procedure in higher-order procedures. She is likely getting at the fact that if `unless` is a procedure, it can be passed as a value to other procedures.

For example, we could have a list of triples called `data-records`, where the first value is our expected condition, the second value is the expected value to return, and the third value is an exceptional value, and map `unless` on the values (albeit we need to use `lambda` and `apply` to make the data structure fit).

``` Scheme
(define (unless condition usual-value exceptional-value)
  (if condition exceptional-value usual-value))

(define data-records
  (list (list (< 1 0) "expected" "impossible")
        (list (= 5 7) "expected" "impossible")))

(map (lambda (record)
       (apply unless record))
     data-records)
;Value: ("expected" "expected")
```

However, this ignores the problem pointed out in Exercise 4.25. `"impossible"` couldn't be replaced with `(/ 1 0)`, for example.